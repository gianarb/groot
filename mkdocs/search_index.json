{
    "docs": [
        {
            "location": "/", 
            "text": "What is Penny?\n\n\nPenny is a framework that helps us to build middleware applications, it is based on an event system and allows us to combine the perfect libraries for our application.\n\n\nPerfect Libraries\n\n\nPHP has a very powerful open source ecosystem. There are a lot of developers and a lot of companies that work and put effort  on some of the best libraries with which we can use to build our applications.\nPenny was born to manage integration between our favorite libraries and it does not force us to use nothing we don't want to.\n\n\nThe Core\n\n\nPenny is very easy its core is built using \nPHP-DI\n a strong dependency injection library.\nIn its base implementation it uses \nnikic/FastRoute\n a fast regular expression based router.\n\n\nThe cost of freedom\n\n\nThis freedom requires a strong knowledge of the Dependency Injection pattern and a deep understanding of the open source ecosystem is essential to choose the perfect mix of libraries with which build our application.\n\n\nHere are a \nlist of implementation examples\n to help us with our development process.", 
            "title": "Introduction"
        }, 
        {
            "location": "/#what-is-penny", 
            "text": "Penny is a framework that helps us to build middleware applications, it is based on an event system and allows us to combine the perfect libraries for our application.", 
            "title": "What is Penny?"
        }, 
        {
            "location": "/#perfect-libraries", 
            "text": "PHP has a very powerful open source ecosystem. There are a lot of developers and a lot of companies that work and put effort  on some of the best libraries with which we can use to build our applications.\nPenny was born to manage integration between our favorite libraries and it does not force us to use nothing we don't want to.", 
            "title": "Perfect Libraries"
        }, 
        {
            "location": "/#the-core", 
            "text": "Penny is very easy its core is built using  PHP-DI  a strong dependency injection library.\nIn its base implementation it uses  nikic/FastRoute  a fast regular expression based router.", 
            "title": "The Core"
        }, 
        {
            "location": "/#the-cost-of-freedom", 
            "text": "This freedom requires a strong knowledge of the Dependency Injection pattern and a deep understanding of the open source ecosystem is essential to choose the perfect mix of libraries with which build our application.  Here are a  list of implementation examples  to help us with our development process.", 
            "title": "The cost of freedom"
        }, 
        {
            "location": "/getting-started/", 
            "text": "Getting Started\n\n\nPenny is a framework that helps us to build OUR own application.\nIn this tutorial we will try to build our first skeleton application.\n\n\nThis simple application needs some third-party php components:\n\n\n\n\ntheleague/plates\n the template system used to render our page.\n\n\ndoctrine/doctrine\n the ORM, used to persist and load our data from/to the MySQL database.\n\n\nzendframework/zend-form\n to create forms used manipulate our data.\n\n\n\n\nIn this tutorial I also used \nbower\n and \ngrunt\n to manage fronted assets.\n\n\nInstall\n\n\ncomposer require gianarb/penny:dev-master\n\n\n\n\nFoldering\n\n\nPenny is just the base framework, to build an application is also necessary a good folder structure.\n\n\nThis tutorial proposal is:\n\n\n.\n\u251c\u2500\u2500 app\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 Controller\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 Form\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 Entity\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 ...\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 view\n\u251c\u2500\u2500 bower.json\n\u251c\u2500\u2500 composer.json\n\u251c\u2500\u2500 config\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 di.php\n\u251c\u2500\u2500 Gruntfile.js\n\u251c\u2500\u2500 package.json\n\u251c\u2500\u2500 vendor\n\u2514\u2500\u2500 public\n \u00a0  \u2514\u2500\u2500 index.php\n\n\n\n\n\n\napp\n contains application files.\n\n\nconfig\n is the folder from which penny loads dependency injection configurations by default.\n\n\n\n\nEvery application has an entry point, \npublic/index.php\n is our.\n\n\n// /public/index.php\n\n\n?php\nuse Penny\\App;\n\nchdir(dirname(__DIR__));\nrequire \nvendor/autoload.php\n;\n\n$app = new App();\n$emitter = new \\Zend\\Diactoros\\Response\\SapiEmitter();\n$emitter-\nemit($app-\nrun());\n\n\n\n\nThe \nPenny\\App\n allow us to pass Container that instance of \nInterop\\Container\\ContainerInterface\n, if we don't supply any, it will load using PHP DI that will read \n./config/{{*}}{{,*.local}}.php\n as default. For custom path for config to be read with PHP DI, we can specify:\n\n\nuse Penny\\App;\nuse Penny\\Config\\Loader;\nuse Penny\\Container;\n\n$config = Loader::load(\n./config/{{*}}{{,*.local}}.php\n);\n$app    = new App(Container\\PHPDiFactory::buildContainer($config));\n\n\n\n\nTo build penny app, we can create these directories or clone \npenny-foldering\n.\n\n\ngit clone git@github.com:gianarb/penny-foldering ./penny-app\ncd penny-app\ncomposer install\n\n\n\n\nThere is easier way, use \npenny-skeleton-app\n.\n\n\nWebServer\n\n\nOf course we can use our favorite web server. Here are just a few examples\n\n\nPHP\n\n\nWe can use the PHP Internal Server. We can go to the root of project, and run the following command:\n\n\nphp -S 127.0.0.0:8085 -t public\n\n\n\n\nNGINX/PHP-FPM configuration\n\n\nnginx/server.d/example.conf\n\n\nupstream fpm {\n    server unix:/var/run/fpm-example.sock;\n}\n\nserver {\n    listen 80;\n    server_name example.com;\n    proxy_pass_header Server;\n    root /var/www/example/public;\n    index index.php;\n\n    location / {\n        try_files                       $uri $uri/ /index.php$is_args$args;\n    }\n\n    location ~* .php$ {\n        fastcgi_pass                    fpm;\n        fastcgi_param                   SCRIPT_FILENAME /opt/example/public/index.php;\n        include fastcgi_params\n    }\n}\n\n\n\n\nphp/etc/pool.d/example.conf\n\n\n[example]\n\n\nuser = fpm\ngroup = fpm\n\nlisten = /var/run/fpm-example.sock\n\npm = dynamic\npm.max_children = 20\npm.start_servers = 10\npm.min_spare_servers = 10\npm.max_spare_servers = 10\npm.max_requests = 100\n\nchdir = /var/www/example/\n\nsecurity.limit_extensions = .php .phtml\n\nrequest_terminate_timeout = 600\n\n\n\n\nDependency Injection and routing configuration\n\n\nAt the moment the default DiC library is PHP-DI and in this tutorial I use it.\n\n\nThe default path where penny look for configuration files is the \nconfig\n directory.\nFiles whose name match the \n*.php\n  pattern are loaded first and then it loads files whose name match the \n*.local.php\n pattern.\nThis strategy is  useful to do configuration overriding for things like database credentials or external services api keys.\n\n\nThe first step is to define a routing strategy, at the moment I'm using \nnikic/FastRoute\n and, as the name state, it is very fast and surprisingly easy to use.\n\n\nAt this point we can use the DI to load the router decoupling the routing library by the framework.\n\n\nCreate \n/config/config.app.php\n\n\n?php\nreturn [\n    \nrouter\n =\n function () {\n        return \\FastRoute\\simpleDispatcher(function (\\FastRoute\\RouteCollector $r) {\n            $r-\naddRoute('GET', '/', ['PennyApp\\Controller\\IndexController', 'index']);\n            $r-\naddRoute('POST', '/', ['PennyApp\\Controller\\IndexController', 'index']);\n        });\n    },\n];\n\n\n\n\nIn this way GET / resolves to the \nPennyApp\\Controller\\IndexController\n controller and then it calls the \nindex\n action.\n\n\nThis is our first route :tada:, now we need the corresponding controller, let's see how to create one.\n\n\nAutoloading\n\n\nTo manage autoloading we use \ncomposer\n.\n\n\nWe can add this configuration in our composer.json.\nThis configuration tells our scripts that the \nPennyApp\n namespace resides under the \napp\n directory, that's where we are placing our controllers.\n\n\n{\n    \nautoload\n: {\n        \npsr-4\n: {\n            \nPennyApp\\\\\n: \n./app\n\n        }\n    }\n}\n\n\n\n\nsee the \npenny-foldering composer.json\n for reference\n\n\nNow we are ready to write the controller that resolve our route.\n\n\n// /app/Controller/IndexController.php\n\n\n?php\nnamespace PennyApp\\Controller;\n\nclass IndexController\n{\n    public function index($request, $response)\n    {\n        return $response;\n    }\n}\n\n\n\n\nPretty easy right? This is our controller and our action waiting $request and $response,\n\n\nthe above implementation uses \nZend\\Diactoros\n and it is PSR-7 compatible.\n\n\nTemplating with Plates\n\n\nPlates\n is a native PHP template system that\u2019s fast, easy to use and easy to extend.\n\n\nHere's how to add it to our application:\n\n\n// /config/config.app.php\n\n?php\nreturn [\n    \nrouter\n =\n function () {\n        return \\FastRoute\\simpleDispatcher(function (\\FastRoute\\RouteCollector $r) {\n            $r-\naddRoute('GET', '/', ['PennyApp\\Controller\\IndexController', 'index']);\n            $r-\naddRoute('POST', '/', ['PennyApp\\Controller\\IndexController', 'index']);\n        });\n    },\n    \ntemplate\n =\n \\DI\\object(\\League\\Plates\\Engine::class)\n        -\nconstructor(\n./app/view/\n), // ./app/view is the path of our templates\n];\n\n\n\n\nNow, we can use it in our controller, update it and create our first template!\n\n\n// /app/Controller/IndexController.php\n\n\n?php\nnamespace PennyApp\\Controller;\n\nclass IndexController\n{\n    /**\n     * @Inject(\ntemplate\n)\n     */\n    private $template;\n\n    public function index($request, $response)\n    {\n        $response-\ngetBody()-\nwrite($this-\ntemplate-\nrender(\nindex\n, [\n            \nname\n =\n \ndeveloper\n\n        ]));\n        return $response;\n    }\n}\n\n\n\n\n!-- /app/view/index.php --\n\n\nhtml\n\n    \nhead\n\n        \ntitle\nPenny Application\n/title\n\n    \n/head\n\n    \nbody\n\n        \nh1\nHi! I'm a \n?php echo $name; ?\n/h1\n\n    \n/body\n\n\n/html\n\n\n\n\n\nDatabase integration with Doctrine 2\n\n\nWe are using \nDoctrine\n which is a popular Object Relational Mapper (ORM) library and the following  is it's basic configuration copied directly by\n official site.\n\n\n?php\nuse Doctrine\\ORM\\Tools\\Setup;\nuse Doctrine\\ORM\\EntityManager;\n\nrequire_once \nvendor/autoload.php\n;\n\n$isDevMode = true;\n$config = Setup::createAnnotationMetadataConfiguration(array(__DIR__.\n/src\n), $isDevMode);\n$conn = array(\n    'driver' =\n 'pdo_sqlite',\n    'path' =\n __DIR__ . '/db.sqlite',\n);\n$entityManager = EntityManager::create($conn, $config);\n\n\n\n\nLet's see how to integrate it in Penny using the Dependency injection container.\n\n\n// /config/app.config.php\n\n?php\nreturn [\n    \nparameters\n =\n [\n        \ndoctrine\n =\n [\n            \norm\n =\n [\n                \ndevMode\n =\n true,\n                \nentityPaths\n =\n [__DIR__.\n/../app/Entity\n],\n                \nproxiyDir\n =\n __DIR__.\n/cache\n,\n                \ncacheDir\n =\n __DIR__.\n/cache\n,\n            ],\n            \nconn\n =\n [\n                \ndriver\n =\n \npdo_mysql\n,\n                'dbname' =\n 'translate',\n                'user' =\n 'root',\n                'password' =\n 'root',\n                'host' =\n '127.0.0.1',\n            ]\n        ]\n    ],\n    \nrouter\n =\n function () {\n        return \\FastRoute\\simpleDispatcher(function (\\FastRoute\\RouteCollector $r) {\n            $r-\naddRoute('GET', '/', ['PennyApp\\Controller\\IndexController', 'index']);\n            $r-\naddRoute('POST', '/', ['PennyApp\\Controller\\IndexController', 'index']);\n        });\n    },\n    \ntemplate\n =\n \\DI\\object(\\League\\Plates\\Engine::class)\n        -\nconstructor(\n./app/view/\n), // ./app/view is the path of our templates\n\n    \ndoctrine.dbal\n =\n \\DI\\factory(function (\\DI\\Container $c) {\n        return Doctrine\\DBAL\\DriverManager::getConnection($c-\nget(\nparameters\n)[\ndoctrine\n][\nconn\n]);\n    }),\n    \ndoctrine.em\n =\n \\DI\\factory(function (\\DI\\Container $c) {\n        $config = Setup::createAnnotationMetadataConfiguration(\n            $c-\nget(\nparameters\n)['doctrine']['orm']['entityPaths'],\n            $c-\nget(\nparameters\n)[\ndoctrine\n][\norm\n][\ndevMode\n],\n            null,\n            null,\n            false\n        );\n        $dbal = $c-\nget(\ndoctrine.dbal\n);\n        return EntityManager::create($dbal, $config);\n    }),\n];\n\n\n\n\nAdding sensitive parameters (like database credentials) into the VCS is a very dangerous and bad practice, the \nconn\n configuration into the \nparameters\n array is the default,  VCS committed. not working one.\n\n\nWe can override it in the local environment, adding a \n/config/*.local.php\n file where keys override the default ones provided in the default configuration.\n\n\n?php\n// /config/local.php\nreturn [\n    \nparameters\n =\n [\n        \ndoctrine\n =\n [\n            \nconn\n =\n [\n                'user' =\n 'applicationdatabase',\n                'password' =\n '35hw4gesgve4b',\n            ]\n        ]\n    ],\n];\n\n\n\n\nAdd it into the .gitignore\n\n\nDoctrine has an awesome console that helps us to manage database, schema, cache an a lot of other stuff.\n\nTODO\n: we should give an overview on how to do in Penny things contained in  \nthis chapter\n.\n\n\n?php\n// cli-config.php\nrequire \nvendor/autoload.php\n;\n\n$app = new \\Penny\\App();\nreturn \\Doctrine\\ORM\\Tools\\Console\\ConsoleRunner::createHelperSet($app-\ngetContainer()-\nget(\ndoctrine.em\n));\n\n\n\n\nNow we are ready to use it in our app writing our first entity.\n\n\n// /app/Entity/Car.php\n\n?php\nnamespace PennyApp\\Entity;\n\nuse Doctrine\\ORM\\Mapping as ORM;\n\n/**\n * @ORM\\Table(name=\nbeers\n)\n * @ORM\\Entity()\n */\nclass Beer\n{\n    /**\n     * @ORM\\Column(type=\ninteger\n)\n     * @ORM\\Id\n     * @ORM\\GeneratedValue(strategy=\nAUTO\n)\n     */\n    private $id;\n\n    /**\n     * @ORM\\Column(type=\nstring\n, nullable=false)\n     */\n    private $name;\n\n    /**\n     * @ORM\\Column(type=\nstring\n, nullable=false)\n     */\n    private $nation;\n\n    public function getId()\n    {\n        return $this-\nid;\n    }\n\n    public function setName($name)\n    {\n        $this-\nname = $name;\n        return $this;\n    }\n\n    public function getName()\n    {\n        return $this-\nname;\n    }\n\n    public function setNation($nation)\n    {\n        $this-\nnation = $nation;\n        return $this;\n    }\n\n    public function getNation()\n    {\n        return $this-\nnation;\n    }\n}\n\n\n\n\nForm and Validation\n\n\nBefore persisting new records into the database validate and filter them is necessary. \nZend\\Validator\n and \nZend\\Form\n\nare good components that helps to do that.\n\n\nUpdate composer.json configuration adding them as dependencies.\n\n\n{\n    \nrequire\n: {\n        \ndoctrine/orm\n: \n2.5.*\n,\n        \ngianarb/penny\n: \n~0.1.0\n,\n        \nzendframework/zend-form\n: \n2.5.0\n,\n        \nzendframework/zend-view\n: \n2.5.0\n,\n        \nzendframework/zend-i18n\n: \n2.5.0\n,\n        \nzendframework/zend-escaper\n: \n2.5.0\n,\n        \nzendframework/zend-servicemanager\n: \n2.5.0\n,\n        \nsymfony/console\n: \n2.7.*\n,\n        \nleague/plates\n: \n3.1.*\n\n    },\n    \nrequire-dev\n: {\n        \nphpunit/phpunit\n: \n~4.0\n\n    },\n    \nautoload\n: {\n        \npsr-4\n: {\n          \nPennyApp\\\\\n: \n./app\n\n        }\n    }\n}\n\n\n\n\nWrite the first form:\n\n\n// /app/Form/BeerForm.php\n\n\n?php\nnamespace PennyApp\\Form;\n\nuse Zend\\Form\\Form;\nuse Zend\\Form\\Element\\Hidden;\nuse Zend\\Form\\Element\\Text;\nuse Zend\\Form\\Element\\Submit;\n\nclass BeerForm extends Form\n{\n    public function __construct()\n    {\n        parent::__construct();\n\n        $hidden = new Hidden('id');\n        $this-\nadd($hidden);\n\n        $code = new Text('name');\n        $code-\nsetLabel('Name');\n        $this-\nadd($code);\n\n        $name = new Text('nation');\n        $name-\nsetLabel('Nation');\n        $this-\nadd($name);\n\n        $save = new Submit('save');\n        $save-\nsetValue('Save');\n        $this-\nadd($save);\n    }\n}\n\n\n\n\nPlates is very extensible and now we have a problem, BeerForm require a render! Let's see how to create it:\n\n\n?php\n// /config/app.config.php\n\nuse Doctrine\\ORM\\Tools\\Setup;\nuse Doctrine\\ORM\\EntityManager;\nuse \\Interop\\Container\\ContainerInterface;\n\nreturn [\n    \ntemplate\n =\n \\DI\\object(\\League\\Plates\\Engine::class)\n        -\nconstructor(\n./app/view/\n)\n        -\nmethod(\nregisterFunction\n, \nform\n, function () {\n            $zfView = new \\Zend\\View\\Renderer\\PhpRenderer();\n            $plugins = $zfView-\ngetHelperPluginManager();\n            $config  = new \\Zend\\Form\\View\\HelperConfig;\n            $config-\nconfigureServiceManager($plugins);\n            return $zfView;\n    }),\n    \nform.beer\n =\n \\DI\\object(\\PennyApp\\Form\\BeerForm::class)\n        -\nmethod(\nsetHydrator\n, new \\Zend\\Stdlib\\Hydrator\\ClassMethods()),\n];\n\n\n\n\n!-- /app/view/index.php --\n\n\nhtml\n\n    \nhead\n\n        \ntitle\nPenny Application\n/title\n\n    \n/head\n\n    \nbody\n\n        \nh1\nHi! I'm a \n?php echo $name; ?\n/h1\n\n\n        \np\n/p\n\n\n        \nform method=\nPOST\n role=\nform\n action=\n/\n\n            \ndiv class=\nform-group\n\n                \n?= $this-\nform()-\nformHidden($form-\nget('id')) ?\n\n                \n?= $this-\nform()-\nformRow($form-\nget('name')) ?\n\n                \n?= $this-\nform()-\nformRow($form-\nget('nation')) ?\n\n                \n?= $this-\nform()-\nformRow($form-\nget('save')) ?\n\n            \n/div\n\n        \n/form\n\n\n        \np\n/p\n\n\n        \nul\n\n            \n?php foreach ($beers as $beer) { ?\n\n            \nli\n?php echo $beer-\ngetName() ?\n/li\n\n            \n?php } ?\n\n        \n/ul\n\n    \n/body\n\n\n/html\n\n\n\n\n\nAs we did previously with other things we now inject the form into our controller.\n\n\n// /app/Controller/IndexController.php\n\n\n?php\nnamespace PennyApp\\Controller;\n\nuse PennyApp\\Entity\\Beer;\nuse Zend\\Diactoros\\Response\\RedirectResponse;\n\nclass IndexController\n{\n    /**\n     * @Inject(\ntemplate\n)\n     */\n    private $template;\n\n    /**\n     * @Inject(\ndoctrine.em\n)\n     */\n    private $entityManager;\n\n    /**\n     * @Inject(\nPennyApp\\Form\\BeerForm\n)\n     */\n    private $beerForm;\n\n    public function index($request, $response)\n    {\n        $lang = new Beer();\n        $beers = $this-\nentityManager-\ngetRepository(\nPennyApp\\Entity\\Beer\n)-\nfindAll();\n\n        $form = $this-\nbeerForm-\nbind($lang);\n\n        if ($request-\ngetMethod() == \nPOST\n) {\n            $form-\nsetData($this-\ndecodeQueryParams($request-\ngetBody()-\n__toString()));\n            if ($form-\nisValid()) {\n                $obj = $form-\ngetObject();\n                $this-\nentityManager-\npersist($obj);\n                $this-\nentityManager-\nflush();\n\n                return new RedirectResponse('/', 301);\n            }\n        }\n        $response-\ngetBody()-\nwrite($this-\ntemplate-\nrender(\nindex\n, [\n            \nname\n =\n \ndeveloper\n,\n            \nform\n =\n $beerForm,\n            \nbeers\n =\n $beers,\n        ]));\n        return $response;\n    }\n\n    private function decodeQueryParams($string)\n    {\n        $params = [];\n        foreach (explode('\n', $string) as $chunk) {\n            $param = explode(\n=\n, $chunk);\n            $params[urldecode($param[0])] = urldecode($param[1]);\n        }\n        return $params;\n    }\n}\n\n\n\n\nThat's all for now, we really need your feedback to improve Penny.\n\n\nSOCIAL-ALERT:\n Feedback is important to us. If you want to share your feedback about this document or about Penny, please do it opening an issue or discussing with us on Twitter using the \n#pennyphp hashtag", 
            "title": "Getting started"
        }, 
        {
            "location": "/getting-started/#getting-started", 
            "text": "Penny is a framework that helps us to build OUR own application.\nIn this tutorial we will try to build our first skeleton application.  This simple application needs some third-party php components:   theleague/plates  the template system used to render our page.  doctrine/doctrine  the ORM, used to persist and load our data from/to the MySQL database.  zendframework/zend-form  to create forms used manipulate our data.   In this tutorial I also used  bower  and  grunt  to manage fronted assets.", 
            "title": "Getting Started"
        }, 
        {
            "location": "/getting-started/#install", 
            "text": "composer require gianarb/penny:dev-master", 
            "title": "Install"
        }, 
        {
            "location": "/getting-started/#foldering", 
            "text": "Penny is just the base framework, to build an application is also necessary a good folder structure.  This tutorial proposal is:  .\n\u251c\u2500\u2500 app\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 Controller\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 Form\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 Entity\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 ...\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 view\n\u251c\u2500\u2500 bower.json\n\u251c\u2500\u2500 composer.json\n\u251c\u2500\u2500 config\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 di.php\n\u251c\u2500\u2500 Gruntfile.js\n\u251c\u2500\u2500 package.json\n\u251c\u2500\u2500 vendor\n\u2514\u2500\u2500 public\n \u00a0  \u2514\u2500\u2500 index.php   app  contains application files.  config  is the folder from which penny loads dependency injection configurations by default.   Every application has an entry point,  public/index.php  is our.  // /public/index.php ?php\nuse Penny\\App;\n\nchdir(dirname(__DIR__));\nrequire  vendor/autoload.php ;\n\n$app = new App();\n$emitter = new \\Zend\\Diactoros\\Response\\SapiEmitter();\n$emitter- emit($app- run());  The  Penny\\App  allow us to pass Container that instance of  Interop\\Container\\ContainerInterface , if we don't supply any, it will load using PHP DI that will read  ./config/{{*}}{{,*.local}}.php  as default. For custom path for config to be read with PHP DI, we can specify:  use Penny\\App;\nuse Penny\\Config\\Loader;\nuse Penny\\Container;\n\n$config = Loader::load( ./config/{{*}}{{,*.local}}.php );\n$app    = new App(Container\\PHPDiFactory::buildContainer($config));  To build penny app, we can create these directories or clone  penny-foldering .  git clone git@github.com:gianarb/penny-foldering ./penny-app\ncd penny-app\ncomposer install  There is easier way, use  penny-skeleton-app .", 
            "title": "Foldering"
        }, 
        {
            "location": "/getting-started/#webserver", 
            "text": "Of course we can use our favorite web server. Here are just a few examples", 
            "title": "WebServer"
        }, 
        {
            "location": "/getting-started/#php", 
            "text": "We can use the PHP Internal Server. We can go to the root of project, and run the following command:  php -S 127.0.0.0:8085 -t public", 
            "title": "PHP"
        }, 
        {
            "location": "/getting-started/#nginxphp-fpm-configuration", 
            "text": "nginx/server.d/example.conf  upstream fpm {\n    server unix:/var/run/fpm-example.sock;\n}\n\nserver {\n    listen 80;\n    server_name example.com;\n    proxy_pass_header Server;\n    root /var/www/example/public;\n    index index.php;\n\n    location / {\n        try_files                       $uri $uri/ /index.php$is_args$args;\n    }\n\n    location ~* .php$ {\n        fastcgi_pass                    fpm;\n        fastcgi_param                   SCRIPT_FILENAME /opt/example/public/index.php;\n        include fastcgi_params\n    }\n}  php/etc/pool.d/example.conf  [example]\n\n\nuser = fpm\ngroup = fpm\n\nlisten = /var/run/fpm-example.sock\n\npm = dynamic\npm.max_children = 20\npm.start_servers = 10\npm.min_spare_servers = 10\npm.max_spare_servers = 10\npm.max_requests = 100\n\nchdir = /var/www/example/\n\nsecurity.limit_extensions = .php .phtml\n\nrequest_terminate_timeout = 600", 
            "title": "NGINX/PHP-FPM configuration"
        }, 
        {
            "location": "/getting-started/#dependency-injection-and-routing-configuration", 
            "text": "At the moment the default DiC library is PHP-DI and in this tutorial I use it.  The default path where penny look for configuration files is the  config  directory.\nFiles whose name match the  *.php   pattern are loaded first and then it loads files whose name match the  *.local.php  pattern.\nThis strategy is  useful to do configuration overriding for things like database credentials or external services api keys.  The first step is to define a routing strategy, at the moment I'm using  nikic/FastRoute  and, as the name state, it is very fast and surprisingly easy to use.  At this point we can use the DI to load the router decoupling the routing library by the framework.  Create  /config/config.app.php  ?php\nreturn [\n     router  =  function () {\n        return \\FastRoute\\simpleDispatcher(function (\\FastRoute\\RouteCollector $r) {\n            $r- addRoute('GET', '/', ['PennyApp\\Controller\\IndexController', 'index']);\n            $r- addRoute('POST', '/', ['PennyApp\\Controller\\IndexController', 'index']);\n        });\n    },\n];  In this way GET / resolves to the  PennyApp\\Controller\\IndexController  controller and then it calls the  index  action.  This is our first route :tada:, now we need the corresponding controller, let's see how to create one.", 
            "title": "Dependency Injection and routing configuration"
        }, 
        {
            "location": "/getting-started/#autoloading", 
            "text": "To manage autoloading we use  composer .  We can add this configuration in our composer.json.\nThis configuration tells our scripts that the  PennyApp  namespace resides under the  app  directory, that's where we are placing our controllers.  {\n     autoload : {\n         psr-4 : {\n             PennyApp\\\\ :  ./app \n        }\n    }\n}  see the  penny-foldering composer.json  for reference  Now we are ready to write the controller that resolve our route.  // /app/Controller/IndexController.php ?php\nnamespace PennyApp\\Controller;\n\nclass IndexController\n{\n    public function index($request, $response)\n    {\n        return $response;\n    }\n}  Pretty easy right? This is our controller and our action waiting $request and $response,  the above implementation uses  Zend\\Diactoros  and it is PSR-7 compatible.", 
            "title": "Autoloading"
        }, 
        {
            "location": "/getting-started/#templating-with-plates", 
            "text": "Plates  is a native PHP template system that\u2019s fast, easy to use and easy to extend.  Here's how to add it to our application:  // /config/config.app.php ?php\nreturn [\n     router  =  function () {\n        return \\FastRoute\\simpleDispatcher(function (\\FastRoute\\RouteCollector $r) {\n            $r- addRoute('GET', '/', ['PennyApp\\Controller\\IndexController', 'index']);\n            $r- addRoute('POST', '/', ['PennyApp\\Controller\\IndexController', 'index']);\n        });\n    },\n     template  =  \\DI\\object(\\League\\Plates\\Engine::class)\n        - constructor( ./app/view/ ), // ./app/view is the path of our templates\n];  Now, we can use it in our controller, update it and create our first template!  // /app/Controller/IndexController.php ?php\nnamespace PennyApp\\Controller;\n\nclass IndexController\n{\n    /**\n     * @Inject( template )\n     */\n    private $template;\n\n    public function index($request, $response)\n    {\n        $response- getBody()- write($this- template- render( index , [\n             name  =   developer \n        ]));\n        return $response;\n    }\n}  !-- /app/view/index.php --  html \n     head \n         title Penny Application /title \n     /head \n     body \n         h1 Hi! I'm a  ?php echo $name; ? /h1 \n     /body  /html", 
            "title": "Templating with Plates"
        }, 
        {
            "location": "/getting-started/#database-integration-with-doctrine-2", 
            "text": "We are using  Doctrine  which is a popular Object Relational Mapper (ORM) library and the following  is it's basic configuration copied directly by\n official site.  ?php\nuse Doctrine\\ORM\\Tools\\Setup;\nuse Doctrine\\ORM\\EntityManager;\n\nrequire_once  vendor/autoload.php ;\n\n$isDevMode = true;\n$config = Setup::createAnnotationMetadataConfiguration(array(__DIR__. /src ), $isDevMode);\n$conn = array(\n    'driver' =  'pdo_sqlite',\n    'path' =  __DIR__ . '/db.sqlite',\n);\n$entityManager = EntityManager::create($conn, $config);  Let's see how to integrate it in Penny using the Dependency injection container.  // /config/app.config.php ?php\nreturn [\n     parameters  =  [\n         doctrine  =  [\n             orm  =  [\n                 devMode  =  true,\n                 entityPaths  =  [__DIR__. /../app/Entity ],\n                 proxiyDir  =  __DIR__. /cache ,\n                 cacheDir  =  __DIR__. /cache ,\n            ],\n             conn  =  [\n                 driver  =   pdo_mysql ,\n                'dbname' =  'translate',\n                'user' =  'root',\n                'password' =  'root',\n                'host' =  '127.0.0.1',\n            ]\n        ]\n    ],\n     router  =  function () {\n        return \\FastRoute\\simpleDispatcher(function (\\FastRoute\\RouteCollector $r) {\n            $r- addRoute('GET', '/', ['PennyApp\\Controller\\IndexController', 'index']);\n            $r- addRoute('POST', '/', ['PennyApp\\Controller\\IndexController', 'index']);\n        });\n    },\n     template  =  \\DI\\object(\\League\\Plates\\Engine::class)\n        - constructor( ./app/view/ ), // ./app/view is the path of our templates\n\n     doctrine.dbal  =  \\DI\\factory(function (\\DI\\Container $c) {\n        return Doctrine\\DBAL\\DriverManager::getConnection($c- get( parameters )[ doctrine ][ conn ]);\n    }),\n     doctrine.em  =  \\DI\\factory(function (\\DI\\Container $c) {\n        $config = Setup::createAnnotationMetadataConfiguration(\n            $c- get( parameters )['doctrine']['orm']['entityPaths'],\n            $c- get( parameters )[ doctrine ][ orm ][ devMode ],\n            null,\n            null,\n            false\n        );\n        $dbal = $c- get( doctrine.dbal );\n        return EntityManager::create($dbal, $config);\n    }),\n];  Adding sensitive parameters (like database credentials) into the VCS is a very dangerous and bad practice, the  conn  configuration into the  parameters  array is the default,  VCS committed. not working one.  We can override it in the local environment, adding a  /config/*.local.php  file where keys override the default ones provided in the default configuration.  ?php\n// /config/local.php\nreturn [\n     parameters  =  [\n         doctrine  =  [\n             conn  =  [\n                'user' =  'applicationdatabase',\n                'password' =  '35hw4gesgve4b',\n            ]\n        ]\n    ],\n];  Add it into the .gitignore  Doctrine has an awesome console that helps us to manage database, schema, cache an a lot of other stuff. TODO : we should give an overview on how to do in Penny things contained in   this chapter .  ?php\n// cli-config.php\nrequire  vendor/autoload.php ;\n\n$app = new \\Penny\\App();\nreturn \\Doctrine\\ORM\\Tools\\Console\\ConsoleRunner::createHelperSet($app- getContainer()- get( doctrine.em ));  Now we are ready to use it in our app writing our first entity.  // /app/Entity/Car.php ?php\nnamespace PennyApp\\Entity;\n\nuse Doctrine\\ORM\\Mapping as ORM;\n\n/**\n * @ORM\\Table(name= beers )\n * @ORM\\Entity()\n */\nclass Beer\n{\n    /**\n     * @ORM\\Column(type= integer )\n     * @ORM\\Id\n     * @ORM\\GeneratedValue(strategy= AUTO )\n     */\n    private $id;\n\n    /**\n     * @ORM\\Column(type= string , nullable=false)\n     */\n    private $name;\n\n    /**\n     * @ORM\\Column(type= string , nullable=false)\n     */\n    private $nation;\n\n    public function getId()\n    {\n        return $this- id;\n    }\n\n    public function setName($name)\n    {\n        $this- name = $name;\n        return $this;\n    }\n\n    public function getName()\n    {\n        return $this- name;\n    }\n\n    public function setNation($nation)\n    {\n        $this- nation = $nation;\n        return $this;\n    }\n\n    public function getNation()\n    {\n        return $this- nation;\n    }\n}", 
            "title": "Database integration with Doctrine 2"
        }, 
        {
            "location": "/getting-started/#form-and-validation", 
            "text": "Before persisting new records into the database validate and filter them is necessary.  Zend\\Validator  and  Zend\\Form \nare good components that helps to do that.  Update composer.json configuration adding them as dependencies.  {\n     require : {\n         doctrine/orm :  2.5.* ,\n         gianarb/penny :  ~0.1.0 ,\n         zendframework/zend-form :  2.5.0 ,\n         zendframework/zend-view :  2.5.0 ,\n         zendframework/zend-i18n :  2.5.0 ,\n         zendframework/zend-escaper :  2.5.0 ,\n         zendframework/zend-servicemanager :  2.5.0 ,\n         symfony/console :  2.7.* ,\n         league/plates :  3.1.* \n    },\n     require-dev : {\n         phpunit/phpunit :  ~4.0 \n    },\n     autoload : {\n         psr-4 : {\n           PennyApp\\\\ :  ./app \n        }\n    }\n}  Write the first form:  // /app/Form/BeerForm.php ?php\nnamespace PennyApp\\Form;\n\nuse Zend\\Form\\Form;\nuse Zend\\Form\\Element\\Hidden;\nuse Zend\\Form\\Element\\Text;\nuse Zend\\Form\\Element\\Submit;\n\nclass BeerForm extends Form\n{\n    public function __construct()\n    {\n        parent::__construct();\n\n        $hidden = new Hidden('id');\n        $this- add($hidden);\n\n        $code = new Text('name');\n        $code- setLabel('Name');\n        $this- add($code);\n\n        $name = new Text('nation');\n        $name- setLabel('Nation');\n        $this- add($name);\n\n        $save = new Submit('save');\n        $save- setValue('Save');\n        $this- add($save);\n    }\n}  Plates is very extensible and now we have a problem, BeerForm require a render! Let's see how to create it:  ?php\n// /config/app.config.php\n\nuse Doctrine\\ORM\\Tools\\Setup;\nuse Doctrine\\ORM\\EntityManager;\nuse \\Interop\\Container\\ContainerInterface;\n\nreturn [\n     template  =  \\DI\\object(\\League\\Plates\\Engine::class)\n        - constructor( ./app/view/ )\n        - method( registerFunction ,  form , function () {\n            $zfView = new \\Zend\\View\\Renderer\\PhpRenderer();\n            $plugins = $zfView- getHelperPluginManager();\n            $config  = new \\Zend\\Form\\View\\HelperConfig;\n            $config- configureServiceManager($plugins);\n            return $zfView;\n    }),\n     form.beer  =  \\DI\\object(\\PennyApp\\Form\\BeerForm::class)\n        - method( setHydrator , new \\Zend\\Stdlib\\Hydrator\\ClassMethods()),\n];  !-- /app/view/index.php --  html \n     head \n         title Penny Application /title \n     /head \n     body \n         h1 Hi! I'm a  ?php echo $name; ? /h1 \n\n         p /p \n\n         form method= POST  role= form  action= / \n             div class= form-group \n                 ?= $this- form()- formHidden($form- get('id')) ? \n                 ?= $this- form()- formRow($form- get('name')) ? \n                 ?= $this- form()- formRow($form- get('nation')) ? \n                 ?= $this- form()- formRow($form- get('save')) ? \n             /div \n         /form \n\n         p /p \n\n         ul \n             ?php foreach ($beers as $beer) { ? \n             li ?php echo $beer- getName() ? /li \n             ?php } ? \n         /ul \n     /body  /html   As we did previously with other things we now inject the form into our controller.  // /app/Controller/IndexController.php ?php\nnamespace PennyApp\\Controller;\n\nuse PennyApp\\Entity\\Beer;\nuse Zend\\Diactoros\\Response\\RedirectResponse;\n\nclass IndexController\n{\n    /**\n     * @Inject( template )\n     */\n    private $template;\n\n    /**\n     * @Inject( doctrine.em )\n     */\n    private $entityManager;\n\n    /**\n     * @Inject( PennyApp\\Form\\BeerForm )\n     */\n    private $beerForm;\n\n    public function index($request, $response)\n    {\n        $lang = new Beer();\n        $beers = $this- entityManager- getRepository( PennyApp\\Entity\\Beer )- findAll();\n\n        $form = $this- beerForm- bind($lang);\n\n        if ($request- getMethod() ==  POST ) {\n            $form- setData($this- decodeQueryParams($request- getBody()- __toString()));\n            if ($form- isValid()) {\n                $obj = $form- getObject();\n                $this- entityManager- persist($obj);\n                $this- entityManager- flush();\n\n                return new RedirectResponse('/', 301);\n            }\n        }\n        $response- getBody()- write($this- template- render( index , [\n             name  =   developer ,\n             form  =  $beerForm,\n             beers  =  $beers,\n        ]));\n        return $response;\n    }\n\n    private function decodeQueryParams($string)\n    {\n        $params = [];\n        foreach (explode(' ', $string) as $chunk) {\n            $param = explode( = , $chunk);\n            $params[urldecode($param[0])] = urldecode($param[1]);\n        }\n        return $params;\n    }\n}  That's all for now, we really need your feedback to improve Penny.  SOCIAL-ALERT:  Feedback is important to us. If you want to share your feedback about this document or about Penny, please do it opening an issue or discussing with us on Twitter using the  #pennyphp hashtag", 
            "title": "Form and Validation"
        }, 
        {
            "location": "/skeleton-application/", 
            "text": "Penny Skeleton Application\n\n\nTable of contents\n\n\n\n\nIntroduction\n\n\nInstallation\n\n\nGet it\n\n\nRequirements\n\n\nPHP Dependencies\n\n\nBuild assets\n\n\n\n\n\n\nWeb server setup\n\n\nPHP built-in Web server\n\n\nDocker\n\n\n\n\n\n\nNext Steps\n\n\n\n\nIntroduction\n\n\nThe Penny Skeleton Application aims to be the starting point to bootstrap a typical web application made of controllers and views.\n\n\nRequirements\n\n\n\n\nPHP \n= 5.4 .\n\n\nComposer\n  (Required to manage PHP dependencies).\n\n\nNode and npm  (Required to build frontend assets).\n\n\n\n\nPHP Dependencies\n\n\nPHP dependencies and autoloading are managed trough composer. \nNew to composer?\n.\n\n\nInstallation\n\n\nGet it\n\n\nThe Penny skeleton application is \nhosted on GitHub\n\n\nThe most common ways to get it are:\n\n\nVia Composer\n\n\n$ composer create-project penny/classic-app -s dev\n\n\n\n\nVia git clone\n\n\n$ git clone https://github.com/pennyphp/penny-skeleton-app.git\n$ cd penny-skeleton-app \n composer install\n\n\n\n\nDownloading the latest master archive\n\n\n$ wget -nv -O - https://github.com/pennyphp/penny-skeleton-app/archive/master.zip | tar zx\n$ cd penny-skeleton-app-master \n composer install\n\n\n\n\nBuild assets\n\n\nJavascript front end dependencies are managed trough \nbower\n and built using \ngrunt\n.\nGrunt and other build tools are\n\n\nNote:\n \nThe following commands must be issued in the skeleton application folder\n,\n\n\nResolve node dependencies\n\n\nNote:\n\nbower and grunt require node.js this is only an example of method to manage static asset,\nif we don't have familiarity with this tools, no problem, we can use \nassetic\n,\ndownload all static dependencies into the public dir or other solutions.\n\n\n$ sudo npm install -G grunt-cli\n$ npm install\n\n\n\n\nResolve frontend dependencies\n\n\n$ ./node_modules/bower/bin/bower install\n\n\n\n\nBuild assets\n\n\n$ grunt dev\n\n\n\n\nWeb server setup\n\n\nPHP built-in Web server\n\n\nFor testing purposes only\n we can use the PHP built-in web server\n\n\nIn the skeleton application folder issue a:\n\n\n$ php -S 0.0.0.0:80 -t public\n\n\n\n\nDocker\n\n\nAttention\n: This is configured  as a \ndevelopment\n environment.\nIf we want to use it in production, we have to: disable error reporting, persist logs, disable Z-Ray, raise limits and fine tune our configurations.\n\n\nThe \npenny-skeleton-app\n repository contains a \ndocker-compose.yml.dist\n file which currently configures two containers, one\nrunning the NGINX web server and one running php-fpm.\nThis file should work as is but  \nmust be renamed\n into \ndocker-compose.yml\n. We can modify if we need something specific for our system like paths, ip addresses, ports, additional services (databases, queues, caching layers) and so on.\nRemember that the docker-compose.yml file is in \n.gitignore\n since this is very specific to the current installation.\n\n\nRequirements\n\n\n\n\nDocker \n= 1.6.0\n\n\ndocker-compose\n\n\n\n\nCreate our docker-compose.yml\n\n\n$ cp docker-compose.yml.dist docker-compose.yml\n# edit it for our specific needs\n$ vi docker-compose.yml ```\n\n### Build\nBefore starting, we have to build penny-classic specific images, to do it issue a:\n\n```bash\n$ docker-compose build\n\n\n\n\nUp and running\n\n\n$ docker-compose up -d\n\n\n\n\nZ-Ray\n\n\nZ-Ray is included in the Penny Docker development environment.\n\n\n\n\nEndpoints\n\n\nIP addresses can be configured in \ndocker-compose.yml\n\n\n\n\nApplication:  \nhttp://127.0.0.10\n\n\nZ-Ray:  \nhttp://127.0.0.10:10081/ZendServer\n\n\n\n\nNext Steps\n\n\nAdd links about Doctrine integration, writing templates with Plates, creating forms, validating forms, etc.", 
            "title": "Skeleton Application"
        }, 
        {
            "location": "/skeleton-application/#penny-skeleton-application", 
            "text": "", 
            "title": "Penny Skeleton Application"
        }, 
        {
            "location": "/skeleton-application/#table-of-contents", 
            "text": "Introduction  Installation  Get it  Requirements  PHP Dependencies  Build assets    Web server setup  PHP built-in Web server  Docker    Next Steps", 
            "title": "Table of contents"
        }, 
        {
            "location": "/skeleton-application/#introduction", 
            "text": "The Penny Skeleton Application aims to be the starting point to bootstrap a typical web application made of controllers and views.", 
            "title": "Introduction"
        }, 
        {
            "location": "/skeleton-application/#requirements", 
            "text": "PHP  = 5.4 .  Composer   (Required to manage PHP dependencies).  Node and npm  (Required to build frontend assets).", 
            "title": "Requirements"
        }, 
        {
            "location": "/skeleton-application/#php-dependencies", 
            "text": "PHP dependencies and autoloading are managed trough composer.  New to composer? .", 
            "title": "PHP Dependencies"
        }, 
        {
            "location": "/skeleton-application/#installation", 
            "text": "", 
            "title": "Installation"
        }, 
        {
            "location": "/skeleton-application/#get-it", 
            "text": "The Penny skeleton application is  hosted on GitHub  The most common ways to get it are:  Via Composer  $ composer create-project penny/classic-app -s dev  Via git clone  $ git clone https://github.com/pennyphp/penny-skeleton-app.git\n$ cd penny-skeleton-app   composer install  Downloading the latest master archive  $ wget -nv -O - https://github.com/pennyphp/penny-skeleton-app/archive/master.zip | tar zx\n$ cd penny-skeleton-app-master   composer install", 
            "title": "Get it"
        }, 
        {
            "location": "/skeleton-application/#build-assets", 
            "text": "Javascript front end dependencies are managed trough  bower  and built using  grunt .\nGrunt and other build tools are  Note:   The following commands must be issued in the skeleton application folder ,  Resolve node dependencies  Note: \nbower and grunt require node.js this is only an example of method to manage static asset,\nif we don't have familiarity with this tools, no problem, we can use  assetic ,\ndownload all static dependencies into the public dir or other solutions.  $ sudo npm install -G grunt-cli\n$ npm install  Resolve frontend dependencies  $ ./node_modules/bower/bin/bower install  Build assets  $ grunt dev", 
            "title": "Build assets"
        }, 
        {
            "location": "/skeleton-application/#web-server-setup", 
            "text": "", 
            "title": "Web server setup"
        }, 
        {
            "location": "/skeleton-application/#php-built-in-web-server", 
            "text": "For testing purposes only  we can use the PHP built-in web server  In the skeleton application folder issue a:  $ php -S 0.0.0.0:80 -t public", 
            "title": "PHP built-in Web server"
        }, 
        {
            "location": "/skeleton-application/#docker", 
            "text": "Attention : This is configured  as a  development  environment.\nIf we want to use it in production, we have to: disable error reporting, persist logs, disable Z-Ray, raise limits and fine tune our configurations.  The  penny-skeleton-app  repository contains a  docker-compose.yml.dist  file which currently configures two containers, one\nrunning the NGINX web server and one running php-fpm.\nThis file should work as is but   must be renamed  into  docker-compose.yml . We can modify if we need something specific for our system like paths, ip addresses, ports, additional services (databases, queues, caching layers) and so on.\nRemember that the docker-compose.yml file is in  .gitignore  since this is very specific to the current installation.  Requirements   Docker  = 1.6.0  docker-compose   Create our docker-compose.yml  $ cp docker-compose.yml.dist docker-compose.yml\n# edit it for our specific needs\n$ vi docker-compose.yml ```\n\n### Build\nBefore starting, we have to build penny-classic specific images, to do it issue a:\n\n```bash\n$ docker-compose build  Up and running  $ docker-compose up -d  Z-Ray  Z-Ray is included in the Penny Docker development environment.   Endpoints  IP addresses can be configured in  docker-compose.yml   Application:   http://127.0.0.10  Z-Ray:   http://127.0.0.10:10081/ZendServer", 
            "title": "Docker"
        }, 
        {
            "location": "/skeleton-application/#next-steps", 
            "text": "Add links about Doctrine integration, writing templates with Plates, creating forms, validating forms, etc.", 
            "title": "Next Steps"
        }, 
        {
            "location": "/install/", 
            "text": "Install\n\n\ncomposer require gianarb/penny:dev-master", 
            "title": "Install"
        }, 
        {
            "location": "/install/#install", 
            "text": "composer require gianarb/penny:dev-master", 
            "title": "Install"
        }, 
        {
            "location": "/flow/", 
            "text": "Application Flow\n\n\n\n\nThis is the Penny's flowchart.\nIt is a event-based middleware. There is only one main event that turns into the application flow.  \n\n\nDispatcher tries to match router and request, if this match exists it returns the result, if not, or in case of problems it triggers an \ndispatch_error\n event.\n\n\nThere are two possible kind of problems:\n\n\n\n\nRoute doesn't exist, an \nPenny\\Exception\\RouteNotFoundException\n Exception is thrown;\n\n\nRoute exists but the HTTP Method hasn't been matched, an \nPenny\\Exception\\MethodNotAllowedException\n Exception is thrown;\n\n\n\n\nIf no exception are thrown, a response is returned back.\n\n\nIf a route matches, the corresponding callback is invoked, in this case the callable is the \nPennyApp\\Controller\\IndexController\n's  \nindex\n method.\n\n\n$r-\naddRoute('GET', '/', ['PennyApp\\Controller\\IndexController', 'index']);\n\n\n\n\nAt this point the system triggers an event called \nPennyApp\\Controller\\IndexController.index\n with zero priority and execute the route callback.\n\n\nAll listeners attached after and before it will be called correctly until the framework returns response,\nif an exception is thrown it will trigger an event named \nPennyApp\\Controller\\IndexController.index_error\n.\n\n\nThe most common way to manage all exceptions is:\n\n\n?php\nuse DI\\ContainerBuilder;\n\nchdir(dirname(__DIR__));\n\nrequire_once \n./vendor/autoload.php\n;\n\n$app = new \\Penny\\App();\n\n$app-\ngetContainer()-\nget(\nevent_manager\n)-\nattach(\n*\n, function ($event) {\n    $e = $event-\ngetException();\n    if ($e instanceof Exception) {\n        throw $e;\n    }\n});\n\n$emitter = new \\Zend\\Diactoros\\Response\\SapiEmitter();\n$emitter-\nemit($app-\nrun());", 
            "title": "Application flow"
        }, 
        {
            "location": "/flow/#application-flow", 
            "text": "This is the Penny's flowchart.\nIt is a event-based middleware. There is only one main event that turns into the application flow.    Dispatcher tries to match router and request, if this match exists it returns the result, if not, or in case of problems it triggers an  dispatch_error  event.  There are two possible kind of problems:   Route doesn't exist, an  Penny\\Exception\\RouteNotFoundException  Exception is thrown;  Route exists but the HTTP Method hasn't been matched, an  Penny\\Exception\\MethodNotAllowedException  Exception is thrown;   If no exception are thrown, a response is returned back.  If a route matches, the corresponding callback is invoked, in this case the callable is the  PennyApp\\Controller\\IndexController 's   index  method.  $r- addRoute('GET', '/', ['PennyApp\\Controller\\IndexController', 'index']);  At this point the system triggers an event called  PennyApp\\Controller\\IndexController.index  with zero priority and execute the route callback.  All listeners attached after and before it will be called correctly until the framework returns response,\nif an exception is thrown it will trigger an event named  PennyApp\\Controller\\IndexController.index_error .  The most common way to manage all exceptions is:  ?php\nuse DI\\ContainerBuilder;\n\nchdir(dirname(__DIR__));\n\nrequire_once  ./vendor/autoload.php ;\n\n$app = new \\Penny\\App();\n\n$app- getContainer()- get( event_manager )- attach( * , function ($event) {\n    $e = $event- getException();\n    if ($e instanceof Exception) {\n        throw $e;\n    }\n});\n\n$emitter = new \\Zend\\Diactoros\\Response\\SapiEmitter();\n$emitter- emit($app- run());", 
            "title": "Application Flow"
        }, 
        {
            "location": "/the-dispatcher-concept/", 
            "text": "The Dispatcher concept\n\n\nHTTP Libraries\n\n\nBy \"HTTP implementation\", it means: \na layer that helps us to work with Request and Response in terms of reading a request, create a response and send it back to the client.\n\n\nIn PHP there are a lot of libraries that do that:\n\n\n\n\nZend\\Http\n\n\nZend\\Diactoros\n\n\nSymfony\\HttpFoundation\n\n\nguzzle/psr7\n\n\n\n\nDispatcher\n\n\nThe \nDispatcher\n (click link to show current implementation), in penny represents the link between: router,\nrequest and response.\n\n\nThe default Penny Dispatcher implementation uses \nZend\\Diactoros\n. We can write our own dispatcher that makes use of our favorite HTTP library\n\n\nMain advantages gained by using \nZend\\Diactoros\n are:\n\n It is supported by the Zend Framework community\n\n It follows PSR-7 standard. \n(what is PSR-7?)\n\n\nIf the dispatch process is good and exists a callable for our request it returns a RouteInfo implementations.\n\n\nPenny, FastRouter and Symfony\\HttpFoundation\n\n\nHere we are going to see how to write a dispatcher to use with the \nSymfony\\HttpFoundation\n component.\n\n\n\n\nInstall it.\n\n\n\n\ncomposer require symfony/http-foundation\n\n\n\n\n\n\nWrite our dispatcher that uses the \nHttpFoundation\\Request\n\n\n\n\n?php\n\nnamespace OurApp\\Dispatcher;\n\nuse Symfony\\Component\\HttpFoundation\\Request;\n\nclass FastSymfonyDispatcher\n{\n    private $router;\n\n    public function __construct($router)\n    {\n        $this-\nrouter = $router;\n    }\n\n    public function dispatch(Request $request)\n    {\n        $routeInfo = $this-\nrouter-\ndispatch($request-\ngetMethod(), $request-\ngetPathInfo());\n        switch ($routeInfo[0]) {\n            case \\FastRoute\\Dispatcher::NOT_FOUND:\n                throw new \\Penny\\Exception\\RouteNotFoundException();\n                break;\n            case \\FastRoute\\Dispatcher::METHOD_NOT_ALLOWED:\n                throw new \\Penny\\Exception\\MethodNotAllowedException();\n                break;\n            case \\FastRoute\\Dispatcher::FOUND:\n                return $routeInfo;\n                break;\n            default:\n                throw new \\Exception(null, 500);\n                break;\n        }\n    }\n}\n\n\n\n\n\n\n\nCreate custom endpoint that consume \nSymfony\\Component\\HttpFoundation\\Request\n and \nResponse\n\n\n\n\n?php\nuse Penny\\App;\nuse OurApp\\Dispatcher\\FastSymfonyDispatcher;\nuse Symfony\\Component\\HttpFoundation\\Request;\nuse Symfony\\Component\\HttpFoundation\\Response;\n\n$this-\napp = new App();\n$dispatcher = new FastSymfonyDispatcher($router);\n$this-\napp-\ngetContainer()-\nset(\ndispatcher\n, $dispatcher);\n$this-\napp-\nrun($request, $response);\n\n\n\n\nNow our application runs using the  \nSymfony\\HttpFoundation\n instead of \nZend\\Diactoros\n.", 
            "title": "The dispatcher concept"
        }, 
        {
            "location": "/the-dispatcher-concept/#the-dispatcher-concept", 
            "text": "", 
            "title": "The Dispatcher concept"
        }, 
        {
            "location": "/the-dispatcher-concept/#http-libraries", 
            "text": "By \"HTTP implementation\", it means:  a layer that helps us to work with Request and Response in terms of reading a request, create a response and send it back to the client.  In PHP there are a lot of libraries that do that:   Zend\\Http  Zend\\Diactoros  Symfony\\HttpFoundation  guzzle/psr7", 
            "title": "HTTP Libraries"
        }, 
        {
            "location": "/the-dispatcher-concept/#dispatcher", 
            "text": "The  Dispatcher  (click link to show current implementation), in penny represents the link between: router,\nrequest and response.  The default Penny Dispatcher implementation uses  Zend\\Diactoros . We can write our own dispatcher that makes use of our favorite HTTP library  Main advantages gained by using  Zend\\Diactoros  are:  It is supported by the Zend Framework community  It follows PSR-7 standard.  (what is PSR-7?)  If the dispatch process is good and exists a callable for our request it returns a RouteInfo implementations.", 
            "title": "Dispatcher"
        }, 
        {
            "location": "/the-dispatcher-concept/#penny-fastrouter-and-symfonyhttpfoundation", 
            "text": "Here we are going to see how to write a dispatcher to use with the  Symfony\\HttpFoundation  component.   Install it.   composer require symfony/http-foundation   Write our dispatcher that uses the  HttpFoundation\\Request   ?php\n\nnamespace OurApp\\Dispatcher;\n\nuse Symfony\\Component\\HttpFoundation\\Request;\n\nclass FastSymfonyDispatcher\n{\n    private $router;\n\n    public function __construct($router)\n    {\n        $this- router = $router;\n    }\n\n    public function dispatch(Request $request)\n    {\n        $routeInfo = $this- router- dispatch($request- getMethod(), $request- getPathInfo());\n        switch ($routeInfo[0]) {\n            case \\FastRoute\\Dispatcher::NOT_FOUND:\n                throw new \\Penny\\Exception\\RouteNotFoundException();\n                break;\n            case \\FastRoute\\Dispatcher::METHOD_NOT_ALLOWED:\n                throw new \\Penny\\Exception\\MethodNotAllowedException();\n                break;\n            case \\FastRoute\\Dispatcher::FOUND:\n                return $routeInfo;\n                break;\n            default:\n                throw new \\Exception(null, 500);\n                break;\n        }\n    }\n}   Create custom endpoint that consume  Symfony\\Component\\HttpFoundation\\Request  and  Response   ?php\nuse Penny\\App;\nuse OurApp\\Dispatcher\\FastSymfonyDispatcher;\nuse Symfony\\Component\\HttpFoundation\\Request;\nuse Symfony\\Component\\HttpFoundation\\Response;\n\n$this- app = new App();\n$dispatcher = new FastSymfonyDispatcher($router);\n$this- app- getContainer()- set( dispatcher , $dispatcher);\n$this- app- run($request, $response);  Now our application runs using the   Symfony\\HttpFoundation  instead of  Zend\\Diactoros .", 
            "title": "Penny, FastRouter and Symfony\\HttpFoundation"
        }, 
        {
            "location": "/use-case/", 
            "text": "Use case\n\n\nThis is the list of \nPenny\n use cases.\nHave you created an application or a skeleton application built on top of Penny?\nOpen a PR and change this list to add yours!\n\n\nSkeletons\n\n\n\n\npenny-foldering\n is a folder structure example. This is the simplest starting point.\n\n\npenny-skeleton-app\n is a skeleton application to build classic web application with an HTML Render.\nIt uses \nthephpleague/plates\n as template engine.\n\n\n\n\nApplications\n\n\n\n\ncurrency-fair\n if you look at the backend directory there's an API system implemented using Penny. It uses \npredis\n and few ZF2 components.\n\n\nbookshelf\n it's a simple book archiving application, that allows the user to create and view a list of books. doctrine, twig\n\n\ntwitter-uservice\n Twitter service to follow hashtag \nAngularConf15", 
            "title": "Use case"
        }, 
        {
            "location": "/use-case/#use-case", 
            "text": "This is the list of  Penny  use cases.\nHave you created an application or a skeleton application built on top of Penny?\nOpen a PR and change this list to add yours!", 
            "title": "Use case"
        }, 
        {
            "location": "/use-case/#skeletons", 
            "text": "penny-foldering  is a folder structure example. This is the simplest starting point.  penny-skeleton-app  is a skeleton application to build classic web application with an HTML Render.\nIt uses  thephpleague/plates  as template engine.", 
            "title": "Skeletons"
        }, 
        {
            "location": "/use-case/#applications", 
            "text": "currency-fair  if you look at the backend directory there's an API system implemented using Penny. It uses  predis  and few ZF2 components.  bookshelf  it's a simple book archiving application, that allows the user to create and view a list of books. doctrine, twig  twitter-uservice  Twitter service to follow hashtag  AngularConf15", 
            "title": "Applications"
        }, 
        {
            "location": "/event-manager-intro/", 
            "text": "Event Manager Introduction\n\n\nPenny provides an \nEventManagerInterface\n that has 2 methods :\n\n\npublic function trigger(EventInterface $event);\npublic function attach($eventName, callable $listener);\n\n\n\n\nThe trigger will execute an event based on registered listeners in our Event Manager, Our Event must implement \nEventInterface\n that has following methods:\n\n\npublic function getName();\npublic function setName($name);\npublic function setResponse($response);\npublic function getResponse();\npublic function setRequest($request);\npublic function getRequest();\npublic function getRouteInfo();\npublic function setRouteInfo(RouteInfoInterface $routerInfo);\npublic function setException(Exception $exception);\npublic function getException();\npublic function stopPropagation($flag = true);\n\n\n\n\nIf we want to uses our own Event Manager implementation in Penny App, there is a proxy provided by Penny for \nZend's EventManager\n, named \nZendEvmProxy\n for sample that we can follow.", 
            "title": "Event Manager Introduction"
        }, 
        {
            "location": "/event-manager-intro/#event-manager-introduction", 
            "text": "Penny provides an  EventManagerInterface  that has 2 methods :  public function trigger(EventInterface $event);\npublic function attach($eventName, callable $listener);  The trigger will execute an event based on registered listeners in our Event Manager, Our Event must implement  EventInterface  that has following methods:  public function getName();\npublic function setName($name);\npublic function setResponse($response);\npublic function getResponse();\npublic function setRequest($request);\npublic function getRequest();\npublic function getRouteInfo();\npublic function setRouteInfo(RouteInfoInterface $routerInfo);\npublic function setException(Exception $exception);\npublic function getException();\npublic function stopPropagation($flag = true);  If we want to uses our own Event Manager implementation in Penny App, there is a proxy provided by Penny for  Zend's EventManager , named  ZendEvmProxy  for sample that we can follow.", 
            "title": "Event Manager Introduction"
        }, 
        {
            "location": "/available-event-manager/", 
            "text": "Available Event Manager\n\n\nPenny provide \nZend's EventManager\n support via \nZendEvmProxy\n.", 
            "title": "Available Event Manager"
        }, 
        {
            "location": "/available-event-manager/#available-event-manager", 
            "text": "Penny provide  Zend's EventManager  support via  ZendEvmProxy .", 
            "title": "Available Event Manager"
        }, 
        {
            "location": "/write-our-event-manager-proxy/", 
            "text": "Write Our Event Manager Proxy\n\n\nWe can write our event manager proxy with the following signature:\n\n\nnamespace App\\EventManager\\Event;\n\nuse Penny\\Event\\EventInterface;\nuse Penny\\Event\\EventManagerInterface;\nuse Our\\Awesome\\EventManager;\n\nclass OurAwesomeEventManagerProxy implements EventManagerInterface\n{\n    /**\n     * @var EventManager\n     */\n    private $eventManager;\n\n    /**\n     * Proxy EventManager\n     */\n    public function __construct()\n    {\n        $this-\neventManager = new EventManager();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public function trigger(EventInterface $event)\n    {\n        $this-\neventManager-\ntrigger($event);\n        return $this;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public function attach($eventName, callable $listener, $priority = 0)\n    {\n        $this-\neventManager-\nattach($eventName, $listener, $priority);\n        return $this;\n    }\n}\n\n\n\n\nAfter that, we can register it as service named 'event_manager' in Our favorite container. For example, we use PHP-DI that may be facilitated by \nPenny\\Container\\PHPDiFactory\n :\n\n\nuse App\\EventManager\\Event\\OurAwesomeEventManagerProxy;\nuse DI;\nuse Penny\\App;\nuse Penny\\Config\\Loader;\nuse Penny\\Container\\PHPDiFactory;\nuse Zend\\Stdlib\\ArrayUtils;\n\n$config = Loader::load(\n./config/{{*}}{{,*.local}}.php\n);\n$config = ArrayUtils::merge(\n    [\n        'event_manager' =\n  DI\\object(OurAwesomeEventManagerProxy::class),\n    ],\n    $config\n);\n\n$app = new App(PHPDiFactory::buildContainer($config));", 
            "title": "Write Our Event Manager Proxy"
        }, 
        {
            "location": "/write-our-event-manager-proxy/#write-our-event-manager-proxy", 
            "text": "We can write our event manager proxy with the following signature:  namespace App\\EventManager\\Event;\n\nuse Penny\\Event\\EventInterface;\nuse Penny\\Event\\EventManagerInterface;\nuse Our\\Awesome\\EventManager;\n\nclass OurAwesomeEventManagerProxy implements EventManagerInterface\n{\n    /**\n     * @var EventManager\n     */\n    private $eventManager;\n\n    /**\n     * Proxy EventManager\n     */\n    public function __construct()\n    {\n        $this- eventManager = new EventManager();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public function trigger(EventInterface $event)\n    {\n        $this- eventManager- trigger($event);\n        return $this;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public function attach($eventName, callable $listener, $priority = 0)\n    {\n        $this- eventManager- attach($eventName, $listener, $priority);\n        return $this;\n    }\n}  After that, we can register it as service named 'event_manager' in Our favorite container. For example, we use PHP-DI that may be facilitated by  Penny\\Container\\PHPDiFactory  :  use App\\EventManager\\Event\\OurAwesomeEventManagerProxy;\nuse DI;\nuse Penny\\App;\nuse Penny\\Config\\Loader;\nuse Penny\\Container\\PHPDiFactory;\nuse Zend\\Stdlib\\ArrayUtils;\n\n$config = Loader::load( ./config/{{*}}{{,*.local}}.php );\n$config = ArrayUtils::merge(\n    [\n        'event_manager' =   DI\\object(OurAwesomeEventManagerProxy::class),\n    ],\n    $config\n);\n\n$app = new App(PHPDiFactory::buildContainer($config));", 
            "title": "Write Our Event Manager Proxy"
        }, 
        {
            "location": "/license/", 
            "text": "Copyright (c) 2015 Gianluca Arbezzano.\n\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.Copyright (c) 2015 Gianluca Arbezzano.", 
            "title": "License"
        }
    ]
}